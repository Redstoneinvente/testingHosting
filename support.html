<body>
  <video id="peer2-to-peer1" autoplay controls style="width:40%;"></video>
  <video id="peer1-to-peer2" autoplay controls style="width:40%;"></video>
</body>

<script>
 var mediaConstraints = {
     optional: [],
     mandatory: {
         OfferToReceiveAudio: true,
         OfferToReceiveVideo: true
     }
 };

 var offerer, answerer;
 var offererToAnswerer = document.getElementById('peer1-to-peer2');
 var answererToOfferer = document.getElementById('peer2-to-peer1');

 window.RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
 window.RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;
 window.RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate || window.webkitRTCIceCandidate;

 navigator.mediaDevices.getUserMedia({ video: true, audio: true })
  .then(stream => {
    // Success: You have the media stream 
    offererPeer(stream);
  })
  .catch(error => {
    // Error handling
    console.error('Error accessing media devices:', error);
  });

 var iceServers = {
     iceServers: [{
         urls: 'stun:stun.l.google.com:19302'
     }]
 };

 /* offerer */

 function offererPeer(stream) {
     offerer = new RTCPeerConnection(iceServers);
     stream.getTracks().forEach(track => {
         offerer.addTrack(track, stream);
     });

     offerer.ontrack = function (event) {
         offererToAnswerer.srcObject = event.streams[0];
         offererToAnswerer.play();
     };

     offerer.onicecandidate = function (event) {
         if (!event || !event.candidate) return;
         answerer.addIceCandidate(event.candidate);
     };

     offerer.createOffer(function (offer) {
         offerer.setLocalDescription(offer)
            .then(() => {
                answererPeer(offer, stream);
            })
            .catch(onSdpError);
     }, onSdpError, mediaConstraints);
 }


 /* answerer */

 function answererPeer(offer, stream) {
     answerer = new RTCPeerConnection(iceServers);
     stream.getTracks().forEach(track => {
         answerer.addTrack(track, stream);
     });

     answerer.ontrack = function (event) {
         answererToOfferer.srcObject = event.streams[0];
         answererToOfferer.play();
     };

     answerer.onicecandidate = function (event) {
         if (!event || !event.candidate) return;
         offerer.addIceCandidate(event.candidate);
     };

     answerer.setRemoteDescription(new RTCSessionDescription(offer))
        .then(() => {
            answerer.createAnswer()
                .then(answer => {
                    answerer.setLocalDescription(answer)
                        .then(() => {
                            offerer.setRemoteDescription(new RTCSessionDescription(answer))
                                .catch(onSdpError);
                        })
                        .catch(onSdpError);
                })
                .catch(onSdpError);
        })
        .catch(onSdpError);
 }

 function onSdpError(error) {
     console.error('SDP error:', error);
 }
</script>
